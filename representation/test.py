# terminal node examples are 'True', 'False', 'A', 'B', 'C'
# function node examples are 'and', 'or', 'not', 'xor'

import random

boolean_func_set = ['and', 'or', 'not', 'xor']
boolean_term_set = ['True', 'False', 'A', 'B', 'C']  

def boolean_arity(func):
    if func == 'not':
        return 1
    else:
        return 2

def generate_full_tree(depth, func_set, term_set):
    if depth == 0:
        return random.choice(term_set)
    else:
        func = random.choice(func_set)
        subtree = [func]  # Root node is the function
        for _ in range(boolean_arity(func)):
            subtree.append(generate_full_tree(depth - 1, func_set, term_set))  # Generate subtrees
        # print(f"subtree generated by full: {subtree}")
        return subtree

def generate_grow_tree(depth, func_set, term_set):
    if depth == 0 or (random.random() < 0.5):
        return random.choice(term_set)
    else:
        func = random.choice(func_set)
        subtree = [func]
        for _ in range(boolean_arity(func)):
            subtree.append(generate_grow_tree(depth - 1, func_set, term_set))
        # print(f"subtree generated by grow: {subtree}")
        return subtree

def ramped_half_and_half(pop_size, max_depth, func_set, term_set):
    population = []
    for depth in range(1, max_depth + 1):
        for _ in range(pop_size // (2 * max_depth)):
            population.append(generate_full_tree(depth, func_set, term_set))

        for _ in range(pop_size // (2 * max_depth)):
            population.append(generate_grow_tree(depth, func_set, term_set))
    return population

population_size = 10
max_tree_depth = 5

population = ramped_half_and_half(population_size, max_tree_depth, boolean_func_set, boolean_term_set)
for tree in population:
    print(tree)
